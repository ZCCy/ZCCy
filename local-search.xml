<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>3月算法小记(March)</title>
    <link href="/2023/03/14/LeetCode/"/>
    <url>/2023/03/14/LeetCode/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-II-005-单词长度的最大乘积"><a href="#剑指-Offer-II-005-单词长度的最大乘积" class="headerlink" title="剑指 Offer II 005. 单词长度的最大乘积"></a><a href="https://leetcode.cn/problems/aseY1I/">剑指 Offer II 005. 单词长度的最大乘积</a></h4><ul><li>比较不同——可以考虑位运算（与）</li><li>全部小写/全部大写字母  —-用<code>int[26]</code>的数组存储表示</li></ul><h4 id="剑指-Offer-II-006-排序数组中两个数字之和"><a href="#剑指-Offer-II-006-排序数组中两个数字之和" class="headerlink" title="剑指 Offer II 006. 排序数组中两个数字之和"></a><a href="https://leetcode.cn/problems/kLl5u1/">剑指 Offer II 006. 排序数组中两个数字之和</a></h4><ul><li><p>用hash实现</p></li><li><p>有序的数组注意二分查找、循环停止条件是<code>(low&lt;=high)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//要找的target</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] nums,target)</span>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (hig - low)/<span class="hljs-number">2</span> + low;<br>    <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>      <span class="hljs-keyword">return</span> mid;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; mid)&#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="剑指-Offer-II-007-数组中和为-0-的三个数"><a href="#剑指-Offer-II-007-数组中和为-0-的三个数" class="headerlink" title="剑指 Offer II 007. 数组中和为 0 的三个数"></a><a href="https://leetcode.cn/problems/1fGaJU/">剑指 Offer II 007. 数组中和为 0 的三个数</a></h4><ul><li>不重复—可以通过排序解决</li><li>数组遍历—-考虑双指针</li></ul><h4 id="剑指-Offer-II-008-和大于等于-target-的最短子数组"><a href="#剑指-Offer-II-008-和大于等于-target-的最短子数组" class="headerlink" title="剑指 Offer II 008. 和大于等于 target 的最短子数组"></a><a href="https://leetcode.cn/problems/2VG8Kg/">剑指 Offer II 008. 和大于等于 target 的最短子数组</a></h4><ul><li><p>连续—-滑动窗口（有个left指针，始终指向最左边）</p></li><li><p>冒泡排序：每次将最大的元素放到最右边：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-comment">// 交换 arr[j] 和 arr[j+1]</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                    arr[j + <span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><ul><li>一个滑动窗口的联系</li></ul><h4 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h4><p>需要抽象出来几个部分：</p><ul><li>节点类<ul><li>定义节点</li></ul></li><li>双向列表<ul><li>定义双向列表</li><li>新增节点到列表尾部方法</li><li>删除某个节点</li><li>删除队尾节点</li></ul></li><li>LRUCache类<ul><li>通过<strong>删除某个节点</strong>+<strong>新增节点</strong>可以实现将某个节点移到对尾更新</li><li>定义HashMap表，将双向列表与HashMap</li></ul></li></ul><h4 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h4><p>堆排序基础知识：</p><ul><li><p>下表为i的节点，父节点，孩子节点的下标分别是：</p><ul><li>父节点：(i-1)/2</li><li>左孩子：i*2+1</li><li>右孩子：i*2+2</li></ul></li><li><p>排序特点</p><ul><li><p>在最大堆中每一次都会产生一个最大值</p></li><li><p>将最大值与最后一个叶子结点交换，重新排序，就又能得到一个最大值（排序时通过使堆的大小-1，实现排除之前找到的最大值）</p><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/4S6w6Z.png" alt="4S6w6Z"></p></li></ul></li></ul><p>使用优先权对列实现：<code>PriorityQueue&lt;Integer&gt;</code></p><p>插入一个元素：<code>`minHeap.offer()</code></p><p>弹出一个最小值：<code>minHeap.poll()</code></p><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><p>递归实现</p><p>递归—&gt;先定位，后进行对节点的访问</p><p>这里先定位到5</p><p>然后从5开始，对每个节点进行反转，将反转之后对节点视为cur一个新的链表</p><p>例如：1-&gt;2-&gt;3&lt;ß-4&lt;-5</p><p>这里cur=3，3之前是反转好的节点</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/ANx58v.png" alt="ANx58v" style="zoom:50%;" /></p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>三月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3月杂记（March）</title>
    <link href="/2023/03/14/LearningSticker/"/>
    <url>/2023/03/14/LearningSticker/</url>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><ul><li><p>举一个java中令人印象深刻的特性：</p><p><strong>1、分层编译</strong></p><ul><li><p>在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。</p><p>长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。</p></li><li><p>Java 7开始引入了分层编译的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：</p><ul><li><strong>解释执行</strong>：在这个层次，JVM 会直接解释 Java 字节码并执行代码。</li><li><strong>执行不带 profiling 的 C1 代码</strong>：在这个层次，JVM 会使用 C1 编译器将代码编译成本地代码，并执行该代码。这个层次的代码通常速度较快，但精度较低。</li><li><strong>执行仅带方法调用次数以及循环回边执行次数 profiling 的 C1 代码</strong>：在这个层次，JVM 会在编译代码时添加一些 profiling 信息，如方法调用次数和循环回边执行次数。这些信息可以用来优化代码并提高执行速度。</li><li><strong>执行带所有 profiling 的 C1 代码</strong>：在这个层次，JVM 会使用更多的 profiling 信息来编译代码，并进一步优化代码。</li><li><strong>执行 C2 代码</strong>：在这个层次，JVM 会使用 C2 编译器将代码编译成高度优化的本地代码，并执行该代码。这个层次的代码通常速度最快，但编译时间较长。</li><li><img src="https://p0.meituan.net/travelcube/9dee40c45e1abb392243e07666ff6d5b79153.png@863w_680h_80q" alt="img" style="zoom:67%;" /><ul><li>图中第①条路径，代表编译的一般情况，热点方法从解释执行到被3层的C1编译，最后被4层的C2编译。</li><li>如果方法比较小（比如Java服务中常见的getter/setter方法），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译之后，放弃进入C2编译，直接选择用1层的C1编译运行。</li><li>在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling ，根据信息直接由第4层的C2编译。</li><li>前文提到C1中的执行效率是1层&gt;2层&gt;3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。</li><li>如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。</li></ul></li></ul></li></ul><p><strong>2、编译优化</strong></p><ul><li><p>（<strong>SSA IR</strong>）Java编译中的中间表达形式：静态单赋值（Static Single Assignment，SSA）IR，SSA 中间表达形式是一种图结构IR，特点是每个变量只能被赋值一次，可以识别出<strong>冗余变量</strong>和<strong>死代码</strong>。</p><p><strong>我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的。</strong></p></li></ul></li></ul><h1 id="DataBase："><a href="#DataBase：" class="headerlink" title="DataBase："></a>DataBase：</h1><h4 id="索引失效的几种原因："><a href="#索引失效的几种原因：" class="headerlink" title="索引失效的几种原因："></a>索引失效的几种原因：</h4><blockquote><p>总结不生效有两种情况：</p><p>1、索引本质就是按照某个字段为数据排序，如果搜索条件用不到拍好的序，就不走索引。</p><p>2、当扫描了数据10%～30%左右的时候，优化器就会放弃索引，自动全表扫。</p><p>参考：<a href="https://www.51cto.com/article/702691.html">https://www.51cto.com/article/702691.html</a></p></blockquote><h5 id="1、联合索引不满足最左匹配原则："><a href="#1、联合索引不满足最左匹配原则：" class="headerlink" title="1、联合索引不满足最左匹配原则："></a>1、联合索引不满足最左匹配原则：</h5><ul><li><p>索引：<code>KEY union_idx(id_no,username,age)</code></p></li><li><p>失效语句：<code>explain select * from t_user where username = &#39;Tom2&#39; and age = 12;</code></p></li><li><p>根本原因：当创建（A,B,C)索引的时候，数据库首先会根据A排序，然后再根据B和C排序。所以如果查询的时候不查A字段的话，就无法匹配索引，导致索引失效。</p><p>另外当创建(A,B,C)索引的时候，其实只有查(A,B,C)的时候才是最快的。</p></li></ul><h5 id="2、通过SELECT索引特定字段可以实现走覆盖索引，如果没有特定字段就会失效："><a href="#2、通过SELECT索引特定字段可以实现走覆盖索引，如果没有特定字段就会失效：" class="headerlink" title="2、通过SELECT索引特定字段可以实现走覆盖索引，如果没有特定字段就会失效："></a>2、通过SELECT索引特定字段可以实现走覆盖索引，如果没有特定字段就会失效：</h5><ul><li>索引：<code>KEY union_idx(id_no,username,age)</code></li><li>走索引语句：<code>explain select id_no, username, age from t_user where username = &#39;Tom2&#39;;</code></li><li>失效语句：<code>explain select * from t_user where username = &#39;Tom2&#39;;</code></li><li>根本原因：创建索引的时候，其实就是将<strong>id_no, username, age</strong>这三列的数据，根据规则放到特定的数据结构中，所以当那这些数据的时候，查询优化器可以直接从索引中拿到对应的值，减少了回表的时长。</li></ul><h5 id="3、索引列使用函数计算："><a href="#3、索引列使用函数计算：" class="headerlink" title="3、索引列使用函数计算："></a>3、索引列使用函数计算：</h5><ul><li><p>索引：<code>KEY union_idx(id)</code></p></li><li><p>失效语句：<code>explain select * from t_user where id + 1 = 2 ;</code></p></li><li><p>根本原因：</p><ul><li><p>索引列使用了函数之后，由于数值改变，需要原先索引的顺序会发生变化，所以会全表扫。</p></li><li><p>非确定性函数（如 RANDOM() 或 NOW()），会在每次调用时产生不同的结果。由于数据库优化器无法预测这些结果，它可能不会选择使用索引。</p></li></ul></li></ul><h5 id="4、LIKE错误使用："><a href="#4、LIKE错误使用：" class="headerlink" title="4、LIKE错误使用："></a>4、LIKE错误使用：</h5><ul><li>失效语句：<code>like &#39;%abc&#39;;ike &#39;%abc%&#39;;</code></li><li>根本原因:<ul><li>索引创建时是按照从左往右创建的，由于在左侧使用了占位符，原先的排序就不生效了。</li></ul></li></ul><h5 id="5、OR不正当使用："><a href="#5、OR不正当使用：" class="headerlink" title="5、OR不正当使用："></a>5、OR不正当使用：</h5><ul><li>失效语句1：<code>explain select * from t_user where id = 2 or username = &#39;Tom2&#39;;</code></li><li>失效语句2: <code>explain select * from t_user where id  &gt; 1 or id  &lt; 80;</code></li><li>根本原因：<ul><li>失效语句1: username没有索引，所以会全表扫</li><li>失效语句2: 当使用 OR 条件连接多个范围查询时，如果两个范围之间有很多数据重叠，查询涵盖的数据量会变大，使得索引的选择性降低。此时，数据库优化器可能会认为全表扫描比使用索引更高效。</li></ul></li></ul><h5 id="6、两列比较："><a href="#6、两列比较：" class="headerlink" title="6、两列比较："></a>6、两列比较：</h5><ul><li>失效语句：<code>explain select * from t_user where id &gt; age;</code></li></ul><h5 id="7、不等于和is-not-null，not-exist："><a href="#7、不等于和is-not-null，not-exist：" class="headerlink" title="7、不等于和is not null，not exist："></a>7、不等于和is not null，not exist：</h5><ul><li><p>失效语句1：<code>explain select * from t_user where create_time != &#39;2022-02-27 09:56:42&#39;;</code></p></li><li><p>失效语句2：<code>explain select * from t_user where id_no is not null;</code></p></li><li><p>根本原因：</p><ul><li><p>当作为字符串的时候，用 != 可能会不走索引：</p><ol><li>索引选择性不佳：当使用 <code>!=</code>（或 <code>&lt;&gt;</code>）操作符时，查询涵盖的数据范围可能相当大，这导致索引的选择性降低。数据库优化器可能认为全表扫描比使用索引更高效。如果查询涉及的数据范围较小，那么索引仍有可能被使用。</li><li>索引顺序与查询顺序不匹配：当 <code>!=</code>（或 <code>&lt;&gt;</code>）操作符与其他条件（如排序和分组）结合使用时，索引失效的可能性更高。因为这些操作要求数据按照特定顺序处理，而索引的顺序可能与这些操作所需的顺序不匹配。</li></ol></li><li><p>Is not null 不走索引：</p><p>1、索引选择性不佳：当大部分行的列值都不为 NULL 时，使用 <code>IS NOT NULL</code> 作为过滤条件可能覆盖了大量数据。在这种情况下，索引的选择性降低，数据库优化器可能会认为全表扫描比使用索引更高效。</p><p>2、数据库优化器决策：根据统计信息和成本评估，数据库优化器可能会判断全表扫描或其他扫描方法（如顺序扫描）比使用索引更合适。优化器会根据数据分布、表大小、硬件资源等因素做出决策，这可能导致 <code>IS NOT NULL</code> 不走索引。</p><p>3、索引类型：某些索引类型可能无法用于 <code>IS NOT NULL</code> 查询。例如，MySQL 的 <strong>MyISAM</strong> 存储引擎不会为全为 NULL 的列创建索引记录。因此，在使用 MyISAM 存储引擎的表中，<code>IS NOT NULL</code> 查询可能无法使用索引。</p></li></ul></li></ul><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h3 id="分布式作业调度："><a href="#分布式作业调度：" class="headerlink" title="分布式作业调度："></a>分布式作业调度：</h3><ul><li><p>xxl-job，elastic-job、saturn</p></li><li><p>分布式工作方式：</p><ul><li><p>xxl-job：</p><ul><li><p>使用 Quartz 基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力</p></li><li><p>调度中心通过获取 DB 锁来保证集群中执行任务的唯一性， 如果短任务很多，随着调度中心集群数量增加，那么数据库的锁竞争会比较厉害，性能不好。</p></li></ul></li><li><p>elastic-job和saturn：</p></li><li><ul><li><p>通过 zookeeper 的注册与发现，可以动态的添加服务器， 支持水平扩容。</p></li><li><p>通过与zookeeper协调，实现任务状态同步，故障转移。（Zookeeper可以储存任务状态、执行结果，同时能够检测故障节点，使调度重新分配任务）</p></li></ul></li></ul></li><li><p>将elastic-job迁移到saturn方案：</p></li><li><p>问题：elastic- job是通过handler注解来标记任务的实现，实现需要重写exacute类，而saturn是直接在控制台创建任务的时候指定对应任务的实现位置（例如com.paic.its.task）位置实现需要重写saturnExacute类。</p></li><li><p>解决方案：</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/8Mi3Vd.png" alt="8Mi3Vd" style="zoom:50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/XZSeoX.png" alt="XZSeoX" style="zoom:50%;" /></p></li></ul><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>SpringMVC老架构（PAFA）：</p><ul><li><p>Tomcat：作为一个独立的软件运行在机器上，作为应用的容器。</p></li><li><p>SpringMVC：也是作为一个独立的软件运行在机器上。</p><p>如何通过TomCat启动SpringMVC是重点。</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/aF7onl.png" alt="aF7onl" style="zoom:50%;" /></p></li></ul><p>SpringBoot：</p><ul><li>SpringBoot将TomCat作为一个jar包嵌入到SpringBoot中</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/fjrI7O.png" alt="fjrI7O" style="zoom:50%;" /></p><h1 id="SpringMVC启动过程："><a href="#SpringMVC启动过程：" class="headerlink" title="SpringMVC启动过程："></a>SpringMVC启动过程：</h1><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/zUi91F.png" alt="zUi91F" style="zoom: 50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/7X0VD4.png" alt="7X0VD4" style="zoom:50%;" /></p><h2 id="1、Tomcat通过接口启动："><a href="#1、Tomcat通过接口启动：" class="headerlink" title="1、Tomcat通过接口启动："></a>1、Tomcat通过接口启动：</h2><ul><li>创建根容器（ApplicationContex）。<ul><li>包含所有bean定义与依赖关系。</li></ul></li><li>然后把根容器放入ServletContext中。<ul><li>代表当前Web应用，可以通过ServletContext与Tomcat通信。可以创建获取静态文件。</li></ul></li><li>接着创建Servlet容器。<ul><li>负责管理Servlet生命周期和Servlet请求，当应用被卸载或容器关闭时，会销毁所有的Servlet实例（订阅者模型）</li></ul></li><li>然后使用Servlet容器去创建核心Servlet（DispatcherServlet）。<ul><li>重点</li></ul></li><li>接着把核心Servlet注册到ServletContext中。</li><li>接着再注册一些过滤器。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/BXATi2.png" alt="BXATi2"></p><h2 id="2、Tomcat通过web-xml启动："><a href="#2、Tomcat通过web-xml启动：" class="headerlink" title="2、Tomcat通过web.xml启动："></a>2、Tomcat通过web.xml启动：</h2><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/Qnxa7H.png" alt="Qnxa7H"></p><p>tomcat web容器启动时会去读取<code>web.xml</code>这样的<code>部署描述文件</code>，相关组件启动顺序为: <code>解析&lt;context-param&gt;</code> =&gt; <code>解析&lt;listener&gt;</code> =&gt; <code>解析&lt;filter&gt;</code> =&gt; <code>解析&lt;servlet&gt;</code>，具体初始化过程如下:</p><ul><li><p>1、解析<code>&lt;context-param&gt;</code>里的键值对。</p></li><li><p>2、创建一个<code>application</code>内置对象即<code>ServletContext</code>，servlet上下文，用于全局共享。</p></li><li><p>3、将<code>&lt;context-param&gt;</code>的键值对放入<code>ServletContext</code>即<code>application</code>中，<code>Web应用</code>内全局共享。</p></li><li><p>4、读取<code>&lt;listener&gt;</code>标签创建监听器，一般会使用<code>ContextLoaderListener类</code>，如果使用了<code>ContextLoaderListener类</code>，<code>Spring</code>就会创建一个<code>WebApplicationContext类</code>的对象，<code>WebApplicationContext类</code>就是<code>IoC容器</code>，<code>ContextLoaderListener类</code>创建的<code>IoC容器</code>是<code>根IoC容器</code>为全局性的，并将其放置在<code>appication</code>中，作为应用内全局共享，键名为<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>，可以通过以下两种方法获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">WebApplicationContext applicationContext = (WebApplicationContext) application.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);<br><br>WebApplicationContext applicationContext1 = WebApplicationContextUtils.getWebApplicationContext(application);<br></code></pre></td></tr></table></figure></li></ul><p>这个全局的<code>根IoC容器</code>只能获取到在该容器中创建的<code>Bean</code>不能访问到其他容器创建的<code>Bean</code>，也就是读取<code>web.xml</code>配置的<code>contextConfigLocation</code>参数的<code>xml文件</code>来创建对应的<code>Bean</code>。</p><ul><li>5、<code>listener</code>创建完成后如果有<code>&lt;filter&gt;</code>则会去创建<code>filter</code>。</li><li>6、初始化创建<code>&lt;servlet&gt;</code>，一般使用<code>DispatchServlet类</code>。</li><li>7、<code>DispatchServlet</code>的父类<code>FrameworkServlet</code>会重写其父类的<code>initServletBean</code>方法，并调用<code>initWebApplicationContext()</code>以及<code>onRefresh()</code>方法。</li><li>8、<code>initWebApplicationContext()</code>方法会创建一个当前<code>servlet</code>的一个<code>IoC子容器</code>，如果存在上述的全局<code>WebApplicationContext</code>则将其设置为<code>父容器</code>，如果不存在上述全局的则<code>父容器</code>为null。</li><li>9、读取<code>&lt;servlet&gt;</code>标签的<code>&lt;init-param&gt;</code>配置的<code>xml文件</code>并加载相关<code>Bean</code>。</li><li>10、<code>onRefresh()</code>方法创建<code>Web应用</code>相关组件。</li></ul><h1 id="SpringBoot自动装配"><a href="#SpringBoot自动装配" class="headerlink" title="SpringBoot自动装配"></a>SpringBoot自动装配</h1><h2 id="1、AutoConfigurationPackage"><a href="#1、AutoConfigurationPackage" class="headerlink" title="1、AutoConfigurationPackage"></a>1、AutoConfigurationPackage</h2><ul><li>在SpringBoot启动的注解<code>SpringBootApplication</code>中有个可以关注的<code>@EnableAutoConfiguration</code>：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/kwiSIp.png" style="zoom:50%;" /></p><ul><li><p>在这个注解内，有<code>@AutoConfigurationPackage</code></p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/FDRS0D.png" alt="FDRS0D" style="zoom:33%;" /></p></li></ul><p>这个注解会去导入Registrar.class到Spring容器中，通过<code>registerBeanDefinitions</code>方法获取当前包的路径：</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/8eYm35.png" alt="" style="zoom:33%;" /></p><p><strong>而其中的这个<code>metadata</code>就是主配置类，所以这个当前包的地址是基于主配置类的地址来获取的，这也就是为什么主配置类的位置必须放在当前包下</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/gML6PK.png" alt="gML6PK" style="zoom:33%;" /></p><h2 id="2、-Import-AutoConfigurationImportSelector-class"><a href="#2、-Import-AutoConfigurationImportSelector-class" class="headerlink" title="2、@Import({AutoConfigurationImportSelector.class})"></a>2、@Import({AutoConfigurationImportSelector.class})</h2><p>通过将<code>AutoConfigurationImportSelector</code>导入Spring容器中，通过层层调用最终到路径为：<code>META-INF/spring.factories</code>的位置获取所有的自动配置类的全类名：</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/OZHfV0.png" alt="" style="zoom: 33%;" /></p><p>然后通过<code>Properties</code>加载资源:</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/tsd8u5.png" style="zoom: 33%;" /></p><p>这样在启动的时候，就能够获取<code>EnableAutoConfig</code>指定的值，并将这些值作为自动配置类导入容器中。</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>三月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot（一）：启动-自动配置</title>
    <link href="/2022/10/31/SpringBoot-Start/"/>
    <url>/2022/10/31/SpringBoot-Start/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot启动机制-自动配置">SpringBoot启动机制-自动配置</h1><h2 id="引入依赖">引入依赖：</h2><ul><li>现在搭建一个基础的SpringBoot项目只需要引入以下依赖：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--MySQL链接驱动--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--springboot web模块支持--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--druid 的数据源--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这些依赖可以帮我们做很多事情，例如<code>mybatis-spring-boot-starter</code>依赖本质上就是一个pom文件，里面包含了很多其他的依赖：</p><p><imgsrc="https://fastly.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/e8Y2LS.png" /></p><h2 id="自动配置">自动配置：</h2><p>自动配置的本质其实还是SpingBoot的IOC机制，这里介绍一下SpringBoot的容器：</p><h3 id="springboot容器">SpringBoot容器：</h3><p>首先要明确容器要解决的问题是什么。在平时的项目中，经常会出现类与类之前的互相调用，例如下图的关系：</p><p><imgsrc="https://fastly.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/82azwr.png" /></p><p>当类的数量没有那么多，且关系并不复杂的时候，人们通常通过new来得到想要的对象。但是当类的关系变得复杂了之后：</p><p><imgsrc="https://fastly.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/yzbJcs.png" /></p><p>显然用到一个对象就new一个不是一个“聪明”的办法</p><p>所以为了降低复杂度，减少他们之间的耦合，这个时候我们就需要用上Spring容器了。这个容器允许我们将创建的类“扔进去”，当其他的类需要这个类的时候，容器会将需要的对象“重新包装”一下拿出来（初始化）。比如上面的A，B，C，D。当创建这些类的时候，我们可以将ABCD都放入容器中，当A需要C的之后，他只需要从容器拿出来就可以了，从而避免了生成大量重复的对象。</p><p>到这里，不经会有一个问题：Spring容器是什么。</p><p>在Spring框架中，ApplicationContext就代表了容器（又叫应用程序上下文），容器里的对象，又叫Bean。</p><p>可以看到上面有两个关键步骤：<strong>放到容器中</strong>，<strong>从容器中拿出来</strong>，那么我们如何在实际的工作中实现呢：</p><p><img src="https://fastly.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/w8R20A.png" alt="" style="zoom:67%;" /></p><p>这是<code>org.mybatis.spring.boot.autoconfigure</code>包下的配置类：<code>MybatisAutoConfiguration</code></p><ul><li><code>@Configuration</code>：标注在类上，配置spring容器(应用上下文)。相当于把该类作为spring的xml配置文件中的<code>&lt;beans&gt;</code>。</li><li><code>@Bean</code>注解标注的方法，返回的类型都会直接注册为<code>bean</code>放到容器中。</li></ul><p>当<code>@Configuration</code>和<code>@Bean</code>一起使用的时候，就可以将<code>SqlSessionFactory</code>的对象以<code>Bean</code>的形式注册到容器中，A类需要使用的时候只需要<code>@Autowire</code>将这个<code>Bean</code>注入到当前A类就可以了。</p><h2id="通过ymlproperites文件实现参数配置">通过yml，properites文件实现参数配置：</h2><p>以Mybatis的配置为例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">a123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-attr">dbcp2:</span><br>      <span class="hljs-attr">min-idle:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">initial-size:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">max-total:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">max-wait-millis:</span> <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>这样的配置是通过packageorg.springframework.boot.autoconfigure.jdb;<code>包下的</code>DataSourceAutoConfiguration`类实现的。这里的自动配置用到了一些条件依赖注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConditionalOnBean</span>     <span class="hljs-comment">//仅在当前上下文中存在某个bean时，才会实例化这个Bean。</span><br><br><span class="hljs-meta">@ConditionalOnClass</span>    <span class="hljs-comment">//某个class位于类路径上，才会实例化这个Bean。</span><br></code></pre></td></tr></table></figure><p>另外一个值得注意的是如果<code>@ConfigurationProperties</code>是在第三方包中，那么<code>@component</code>是不能注册到容器的。只有<code>@EnableConfigurationProperties</code>才可以注册到容器。这里是因为是Mybatis的外部依赖，所以通过这种形式可以将该类注册到我们的SpringBoot容器中。</p><p>可以看到在<code>DataSourceProperties</code>中设置了一些参数，我们只要在yml文件中设置这些参数就可以：</p><p><imgsrc="https://fastly.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/lIxSBr.png" /></p><p><imgsrc="https://fastly.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/image-20220919180247169.png" /></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑回归（logistics-regression）</title>
    <link href="/2022/09/05/SupportVectorMachine/"/>
    <url>/2022/09/05/SupportVectorMachine/</url>
    
    <content type="html"><![CDATA[<p>因此我们的目标是找到一条直线（图中的最优超平面），离所有点的距离最远。由此，SVM算法的实质是找出一个能够将某个值最大化的超平面，这个值就是超平面离所有训练样本的最小距离。这个最小距离用SVM术语来说叫做间隔(margin)。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>分类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K邻近算法（K-Nearest Neighbors）</title>
    <link href="/2022/08/13/K-Nearest%20Neighbors/"/>
    <url>/2022/08/13/K-Nearest%20Neighbors/</url>
    
    <content type="html"><![CDATA[<h1 id="k邻近算法k-nearest-neighbors">K邻近算法（K-NearestNeighbors）</h1><h2 id="一理论学习">一、理论学习：</h2><p>当我们想知道路边一朵特别好看的野花名字的时候，我们可以用百度的图片搜索，将当前这一朵野花与搜出来的许多结果进行对比，然后选择了和它长得最像的一朵，将这一朵花和路边遇到的视为同一朵花，然后再由网上的结果来确定路边这一朵花的品种。</p><p>这样一个确定花品种的过程也就是KNN算法“学习”的过程。网上搜出来的许多花也就是KNN算法预先拥有的样本，路边遇到的野花就是本次要分类的对象，通过计算本次对象与KNN所拥有的样本之间的“距离”，来确定它所处的分类：</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/KNN_Test.png" alt="KNN_Test" style="zoom:67%;" /></p><h2 id="二实践">二、实践：</h2><h3 id="实验过程">实验过程：</h3><ul><li><h4 id="数据集">数据集：</h4><p>该数据集同样描述描述的是一位顾客在年龄和预算的两个条件下是否会购买该商品</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/2HDPb4.png" alt="EpBzio" style="zoom: 40%;" /></p></li><li><h4 id="测试结果">测试结果：</h4><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/KNN_result.png" alt="KNN_result" style="zoom:80%;" /></p></li></ul><h3 id="代码实现">代码实现：</h3><ul><li><h4 id="数据处理">数据处理：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dataset = pd.read_csv(<span class="hljs-string">&#x27;datasets/Social_Network_Ads.csv&#x27;</span>)<br>X = dataset.iloc[:, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]].values<br>y = dataset.iloc[:, <span class="hljs-number">4</span>].values<br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.25</span>, random_state=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li><li><h4 id="对数据进行标准化和归一化">对数据进行标准化和归一化：</h4><p><strong>fit</strong>：原义指的是安装、使适合的意思，其实有点train的含义但是和train不同的是，它并不是一个训练的过程，而是一个适配的过程，过程都是定死的，最后只是得到了一个统一的转换的规则模型。<strong>transform</strong>：是将数据进行转换，比如数据的归一化和标准化，将测试数据按照训练数据同样的模型进行转换，得到特征向量。<strong>fit_transform</strong>：可以看做是fit和transform的结合，如果训练阶段使用fit_transform，则在测试阶段只需要对测试样本进行transform就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">sc = StandardScaler()<br>X_train = sc.fit_transform(X_train)<br>X_test = sc.transform(X_test)<br></code></pre></td></tr></table></figure></li><li><h4id="使用k-nn对训练集数据进行训练">使用K-NN对训练集数据进行训练：</h4><p>由于实现逻辑比较简单，所以这里就直接使用了sklearn中的学习器</p><p>参数说明：<code>n_neighbors</code>就是指的k值，<code>metric</code>时用于树的距离度量。默认度量是<code>minkowski</code>，<code>p=2</code>等价于标准的欧几里德度量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">classifier = KNeighborsClassifier(n_neighbors=<span class="hljs-number">5</span>, metric=<span class="hljs-string">&#x27;minkowski&#x27;</span>, p=<span class="hljs-number">2</span>)<br>classifier.fit(X_train, y_train)<br></code></pre></td></tr></table></figure></li><li><h4 id="对测试集进行预测">对测试集进行预测:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">y_pred = classifier.predict(X_test)<br></code></pre></td></tr></table></figure></li></ul><h2 id="三总结">三、总结：</h2><p>本次实验只是探索了在二维数据的情况下，KNN算法的处理方式，但是当面对高维问题的时候我们就需要进行降维处理，这个将在以后的过程中展开。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>分类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑回归（logistics-regression）</title>
    <link href="/2022/08/09/logistics-regression/"/>
    <url>/2022/08/09/logistics-regression/</url>
    
    <content type="html"><![CDATA[<h1 id="逻辑回归logistics-regression">逻辑回归（logisticsregression）</h1><h2 id="一理论学习">一、理论学习：</h2><p><strong>线性回归模型</strong>可得到：$ y =^Tx+b $，这个模型可以很好的符合当<strong>输入值</strong>（也就是x，条件值）和<strong>输出值</strong>（也就是y，预测值）为<strong>线性函数关系</strong>的时候。那么当<spanclass="math inline">\(x\)</span> 和<spanclass="math inline">\(y\)</span>不再是线性函数映射的时候，线性回归模型的<spanclass="math inline">\(plus\)</span>版：<strong>广义线性模型</strong>：<spanclass="math inline">\(y=g^{-1}(\omega^T+b)\)</span>也可以将<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>联系起来，其中<spanclass="math inline">\(g^{-1}(·)\)</span>就是<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>对应的函数映射。例如本次要探究的<strong>对数几率回归模型</strong>。</p><p>对数几率回归模型的主要应用在各种<strong>二分类</strong>的问题里，在二分类问题里，预测值的值域是<spanclass="math inline">\(\{0,1\}\)</span>。要将线性的输入值投射到的<spanclass="math inline">\(\{0,1\}\)</span>值域区间内，就需要找到一个函数，可以将<spanclass="math inline">\(z\)</span>投射到<spanclass="math inline">\(\{0,1\}\)</span>的的值域内。这样最理想的函数便是接近<strong>单位阶级跃函数</strong>的一个替代函数：<span class="math display">\[y=\frac{1}{1+e^{-z}}\]</span><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/对数几率函数.png" alt="Logistic_Regression_Sigmoid" style="zoom: 20%;" /></p><p>由图可以看到：该函数可以近似为一个单位阶级跃函数： <spanclass="math display">\[\begin{eqnarray}\end{eqnarray}y=\left\{\begin{array}{cc}0, &amp; z&lt;0 \\0.5, &amp; z=0 \\1, &amp; z&gt;0。\end{array}\right.\]</span> 当我们得到了在二分类中的<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>对应的函数映射，将输入值的线性表达带入<spanclass="math inline">\(y=\frac{1}{1+e^{-z}}\)</span>中，便可以得到对数几率回归的模型：<span class="math display">\[h=\frac{1}{1+e^{-(\omega ^Tx+b)}}\]</span></p><p>通过极大似然法（maximum likelihoodmethod），来估计要训练的参数：<spanclass="math inline">\(\omega,b\)</span> <span class="math display">\[L(\omega,b)=\prod_{i=1}^{m} P\left(y_{i} \mid x_{i} ;\omega,b\right)=\prod_{i=1}^{m}\left(h_{\omega,b}\left(x_{i}\right)\right)^{y_{i}}\left(1-h_{\omega,b}\left(x_{i}\right)\right)^{1-y_{i}}\]</span> 接着通过梯度下降法，求出参数<spanclass="math inline">\(\omega,b\)</span>的更新公式： <spanclass="math display">\[\begin{array}{l}\omega_j \leftarrow \omega_j-\alpha \frac{1}{m} {\textstyle\sum_{i=1}^{m}} (h(x_i)-y_i)x_i^j \\b_j \leftarrow b_j-\alpha\frac{1}{m}{\textstyle\sum_{i=1}^{m}}(h(x_i)-y_i)\end{array}\]</span></p><h2 id="二实践">二、实践：</h2><ul><li><p>数据集：该数据集描述的是一位顾客在年龄和预算的两个条件下是否会购买该商品</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/2HDPb4.png" alt="Logistic_Regression_Dataset" style="zoom: 40%;" /></p></li><li><p>测试结果：</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/Logistic_Regression_Result.png" alt="Logistic_Regression_Result" style="zoom:67%;" /></p></li></ul><p>具体会用到的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-keyword">import</span> logistic_regression_mine<br><span class="hljs-keyword">from</span> matplotlib.colors <span class="hljs-keyword">import</span> ListedColormap<br></code></pre></td></tr></table></figure><h4 id="数据归一化与标准化">1、数据归一化与标准化：</h4><ul><li><p>计算训练集的平均值和标准差，以便测试数据集使用相同的变换。一般情况下，在监督学习中，我们需要利用训练集数据对测试集数据进行预测。这里隐含了一个假设，就是训练数据和测试数据实际上是同分布的（因此我们才可以使用训练数据集来预测测试数据集），来自于同一个总体。在进行标准化的过程中就将训练集的均值和方差当做是总体的均值和方差，因此对测试集使用训练集的均值和方差进行预处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">ataset = pd.read_csv(<span class="hljs-string">&#x27;datasets/Social_Network_Ads.csv&#x27;</span>)<br><span class="hljs-comment"># iloc[a:b,c:d]:取行索引从a到b-1，列索引从c到d-1的数据。</span><br><span class="hljs-comment"># iloc[a:b,[c,d]]]:取行索引从a到b-1，列索引从c到d的数据。</span><br><span class="hljs-comment"># iloc[].values，用values属性取值，返回ndarray，但是单个数值无法用values函数读取。</span><br>X = dataset.iloc[:, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]].values  <span class="hljs-comment"># 取年龄和薪资两列</span><br>y = dataset.iloc[:, <span class="hljs-number">4</span>].values  <span class="hljs-comment"># 取出结果（是否购买）</span><br><span class="hljs-comment"># 分割训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.25</span>, random_state=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>关于归一化前后的数据对比：</p><ul><li><p>归一化之前：</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/Normalized-befor.png" alt="Normalized-befor" style="zoom:33%;" /></p></li><li><p>归一化之后：</p><p><img src="https://cdn.jsdelivr.net/gh/ZCCy/Blog-Picture@master/uPic/Normalized-after.png" alt="Normalized-after" style="zoom:33%;" /></p></li></ul></li></ul><h4 id="使用训练集训练并预测">2、使用训练集训练并预测：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">classifier = LogisticRegression()<br>classifier.fit(X_train, y_train)<br>clf = logistic_regression_mine.LogisticRegressionMine(learning_rate=<span class="hljs-number">0.1</span>, max_iter=<span class="hljs-number">500</span>, seed=<span class="hljs-number">272</span>)<br>clf.fit(X_train, y_train)<br>y_pred = clf.predict(X_test)<br></code></pre></td></tr></table></figure><h4 id="图形化处理">3、图形化处理：</h4><ul><li><p>生成可视化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">X_set, y_set = X_test, y_test<br>X1, X2 = np. meshgrid(np. arange(start=X_set[:, <span class="hljs-number">0</span>].<span class="hljs-built_in">min</span>()-<span class="hljs-number">1</span>, stop=X_set[:, <span class="hljs-number">0</span>].<span class="hljs-built_in">max</span>()+<span class="hljs-number">1</span>, step=<span class="hljs-number">0.01</span>),np. arange(start=X_set[:, <span class="hljs-number">1</span>].<span class="hljs-built_in">min</span>()-<span class="hljs-number">1</span>, stop=X_set[:, <span class="hljs-number">1</span>].<span class="hljs-built_in">max</span>()+<span class="hljs-number">1</span>, step=<span class="hljs-number">0.01</span>))<br>plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),<br>             alpha=<span class="hljs-number">0.75</span>, cmap=ListedColormap((<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>)))<br>plt.xlim(X1.<span class="hljs-built_in">min</span>(), X1.<span class="hljs-built_in">max</span>())<br>plt.ylim(X2.<span class="hljs-built_in">min</span>(), X2.<span class="hljs-built_in">max</span>())<br><span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(np. unique(y_set)):<br>    plt.scatter(X_set[y_set == j, <span class="hljs-number">0</span>], X_set[y_set == j, <span class="hljs-number">1</span>],<br>                c=ListedColormap((<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>))(i), label=j)<br>plt. title(<span class="hljs-string">&#x27; LOGISTIC(Test set)&#x27;</span>)<br>plt. xlabel(<span class="hljs-string">&#x27; Age&#x27;</span>)<br>plt. ylabel(<span class="hljs-string">&#x27; Estimated Salary&#x27;</span>)<br>plt. legend()<br>plt. show()<br></code></pre></td></tr></table></figure></li></ul><h4 id="逻辑回归实现类">4、逻辑回归实现类：</h4><ul><li><p>调用接口与初始化函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogisticRegressionMine</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, learning_rate=<span class="hljs-number">0.1</span>, max_iter=<span class="hljs-number">100</span>, seed=<span class="hljs-literal">None</span></span>):<br>        self.seed = seed<br>        self.lr = learning_rate<br>        self.max_iter = max_iter<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fit</span>(<span class="hljs-params">self, x, y</span>):<br>        np.random.seed(self.seed)<br>        self.w = np.random.normal(loc=<span class="hljs-number">0.0</span>, scale=<span class="hljs-number">1.0</span>, size=x.shape[<span class="hljs-number">1</span>])<br>        self.b = np.random.normal(loc=<span class="hljs-number">0.0</span>, scale=<span class="hljs-number">1.0</span>)<br>        self.x = x<br>        self.y = y<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.max_iter):<br>            self._update_step()<br>            <span class="hljs-comment"># print(&#x27;loss: \t&#123;&#125;&#x27;.format(self.loss()))</span><br>            <span class="hljs-comment"># print(&#x27;score: \t&#123;&#125;&#x27;.format(self.score()))</span><br>            <span class="hljs-comment"># print(&#x27;w: \t&#123;&#125;&#x27;.format(self.w))</span><br>            <span class="hljs-comment"># print(&#x27;b: \t&#123;&#125;&#x27;.format(self.b))</span><br></code></pre></td></tr></table></figure></li><li><p>定义sigmoid函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#定义sigmoid函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">self,z</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / (<span class="hljs-number">1</span> + np.exp(-z))<br></code></pre></td></tr></table></figure></li><li><p>将线性实值投射到sigmoid函数上，并计算预测值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">self, x, w, b</span>):<br>    z = x.dot(w) + b<br>    <span class="hljs-keyword">return</span> self.sigmoid(z)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_proba</span>(<span class="hljs-params">self, x=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        x = self.x<br>    y_pred = self._f(x, self.w, self.b)<br>    <span class="hljs-keyword">return</span> y_pred<br><span class="hljs-comment"># 将实值x计算sigmoid的1，0值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, x=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        x = self.x<br>    y_pred_proba = self.f(x, self.w, self.b)<br>    y_pred = np.array([<span class="hljs-number">0</span> <span class="hljs-keyword">if</span> y_pred_proba[i] &lt; <span class="hljs-number">0.5</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y_pred_proba))])<br>    <span class="hljs-keyword">return</span> y_pred<br></code></pre></td></tr></table></figure></li><li><p>更新参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_calc_gradient</span>(<span class="hljs-params">self</span>):<br>    y_pred = self.predict()<br>    d_w = (y_pred - self.y).dot(self.x) / <span class="hljs-built_in">len</span>(self.y)<br>    d_b = np.mean(y_pred - self.y)<br>    <span class="hljs-keyword">return</span> d_w, d_b<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_step</span>(<span class="hljs-params">self</span>):<br>    d_w, d_b = self._calc_gradient()<br>    self.w = self.w - self.lr * d_w<br>    self.b = self.b - self.lr * d_b<br>    <span class="hljs-keyword">return</span> self.w, self.b<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习基础实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>回归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习（一）：启动 _</title>
    <link href="/2022/08/01/SystemStart/"/>
    <url>/2022/08/01/SystemStart/</url>
    
    <content type="html"><![CDATA[<h4 id="打开电源-cpu初始化bios引导">0、打开电源CPU初始化（BIOS引导)</h4><ul><li>加点之后寄存器开始做一些初始化的工作，将CS=0xFFFF，IP=0X0000，于是CPU转去执行0XFFFF0处的指令，这里是一个指向BIOS程序的入口的转跳指令。</li></ul><h4 id="bios启动">1、BIOS启动：</h4><ul><li>PownOn：校验CMOS（CMOS指保存计算机基本启动信息（如日期、时间、启动设置等）的芯片。CMOS是主板上的一块可读写的并行或串行FLASH芯片，是用来保存<ahref="https://baike.baidu.com/item/BIOS">BIOS</a>的硬件配置和用户对某些参数的设定。）是否正常，检验一些硬件状态。</li><li>POST：检查现存，显卡，内存测试。然后进行分配中断、IO端口、DMA资源等，这个时候会建立一个中断向量表和中断服务程序主要用于用户进行键盘和鼠标操作。</li><li>退出：MBR启动盘再第一扇区占512字节，以0XAA55结束，将启动盘程序复制到物理内存0x7C00处。</li></ul><h4 id="boot引导程序">2、boot引导程序：</h4><ul><li>转交给<strong>Loader</strong>（增添boot引导是为了不让loader硬编码）。</li></ul><h4 id="loader引导加载程序">3、Loader引导加载程序</h4><ul><li>检测硬件信息。</li><li>将当前的实模式转变成<strong>保护模式</strong>（32位）或者<strong>IA-32e</strong>（64位）模式。</li><li>实模式下，内存只有1MB，即2^2020个bit表示地址空间（用两个寄存器CS：IP，因为有20根地址线），在保护模式下有4GB的内存空间，就可以将内核启动参数输入到内核启动程序。</li></ul><h4 id="内核头程序">4、内核头程序：</h4><ul><li>对GDT（全局段描述）表，IDT（中断描述）表和页表初始化，为中断处理，内存管理的初始化做准备。</li></ul><h4 id="内核初始化">5、内核初始化</h4><ul><li>首先创建0号进程，对<strong>中断处理</strong>初始化，因为要考虑到可能会有任何异常情况都导致中断。</li><li>接着是<strong>内存</strong>和<strong>进程管理</strong>的初始化，主要涉及如何获取内存信息，进行内存分配，进程控制结构PCB和进程调度。</li><li><strong>文件系统</strong>初始化，创建一个<strong>虚拟文件系统</strong>，有一个挂载目录。解决文件到磁盘逻辑地址映射，磁盘逻辑地址映射到物理地址映射。</li><li>创建1号进程，第一个用户进程，进入到用户态，完成完整的用户文件系统创建过程，就可以访问根文件系统中的init程序做一些用户态初始化。</li><li>创建2号进程，是内核进程的祖先，负责管理调度其它内核进程。</li></ul><h4id="内核态有了调度进程之后用户便可以开始创建自己的进程启动完成">6、内核态有了调度进程之后，用户便可以开始创建自己的进程，启动完成。</h4>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/31/hello-world/"/>
    <url>/2022/07/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
